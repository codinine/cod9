---
layout: post
title: "[알고리즘-기초]06.너비우선탐색(feat.그래프)"
date:   2020-06-29 13:50:26
categories: algorithm
---

#### [](#최단경로문제 "최단경로문제")최단경로문제

여름 휴가가 찾아왔습니다. 우리는 친구들과 강릉 경포대를 가기로 했습니다.  
강릉을 갈 수 있는 방법은 여러가지가 있을겁니다.

1.  기차를 이용한다.
2.  고속버스를 이용한다.
3.  개인차량을 이용한다.
4.  도보로 간다.

또한 강릉을 바로 갈 수도 있고, 대관령에 들려 양떼목장을 구경하고 갈 수도 있겠죠.  
여러 경로와 여러 방법을 통해 강릉에 도착할 수 있는데  
여기서 최단 경로를 찾는 알고리즘이 `너비 우선 탐색`이라고 합니다.

#### [](#그래프 "그래프")그래프

프로그래밍에서 그래프는 정점(node)과 간선(edge)로 이루어져 있습니다.  
자료들의 관계성을 표시한 형태라고 할 수 있습니다.  
![](/images/algorithm-basic-06_1.jpg)  
친구들끼리 가위바위보의 결과를 표시한 그래프 입니다.  
영희와 철수는 가위바위보를 했고, 철수가 이겼습니다.  
이를 토대로 누가 누구와 가위바위보를 하여 승리하였는지 알 수 있고  
아직 승부를 겨루지 못한 친구들도 확인할 수 있습니다.

너비 우선 탐색 알고리즘을 이해하기 위해서는 하나의 자료구조를 추가적으로 더  
알아볼 필요가 있습니다. 바로 `큐` 입니다.

#### [](#큐 "큐")큐

큐는 먼저들어온 데이터를 먼저 탐색하도록 합니다.  
버스 정류장에 사람이 기다리고 있을때 먼저 기다린 사람이 먼저 타는 것과  
같은 원리입니다.  
재귀를 공부했을때 스택에 대해서 알아본적이 있습니다.  
큐와 스택은 보통 같이 묶어서 생각하는 경우가 많습니다.

큐는 `선입 선출`, 스택은 `후입 선출` 구조입니다.

#### [](#너비-우선-탐색 "너비 우선 탐색")너비 우선 탐색

자, 이제 여러분은 자신의 인맥을 최대한 동원하여 `가수`를 찾아야합니다.  
내가 직접 알고 있는 지인이 가수라면 좋겠지만 아니라면 가수를 알고 있을 것 같은  
지인을 통해 가수를 찾을 수 있을겁니다.

예를 들어, 우리 엄마 친구 딸이 어떤 아이돌 그룹의 코디네이터 일을 하고 있다고 합니다.  
그럼 그 `엄친딸`은 가수를 알고 있다고 할 수 있겠죠.  
우리는 그럼 그 아이돌 가수와 연결되기 위해서 몇단계를 거쳐야 하는 걸까요?

나 -> 엄마 -> 엄마친구 -> 엄친딸 -> 가수  
4단계를 거쳐야만 가수를 찾을 수 있습니다. 그런데 생각해보니 예전 내 학교 동창이  
방송연예과를 나왔다는 것을 알게 되었습니다. 그 친구도 가수를 알고 있었던거죠.

그런 경우에는 나 -> 동창 -> 가수  
2단계만 거치면 됩니다.

너비 우선 탐색은 최단 경로를 찾는 방법이므로 아래 방법이 더 올바르다고 할 수 있습니다.  
그럼 이렇게 최단 경로를 찾기 위해서 어떤 탐색 방법을 써야할까요?  
무조건 가수를 알 것 같은 사람을 찾는 것이 아니라 내가 직접 알고있는 모든 지인부터  
확인해야 할겁니다.  
1단계를 모두 확인한 후에 없다면  
2단계를 모두 확인하면 됩니다.

이런 방법으로 찾아야만 최단 경로를 확보할 수 있습니다.  
그럼 너비 우선 탐색을 위의 정보들을 활용하여 직접 구현해 보도록 하겠습니다.

#### [](#구현 "구현")구현

##### [](#Example "Example")Example

```python
#큐를 import 합니다.  
from collections import deque  

# 이름이 가수이면 리턴합니다.  
def find_singer(name):  
 return name == 'IU'  

# 지인 딕셔너리(해시테이블)를 만듭니다.  
graph = {}  
graph["start"] = ["mom", "friend", "teacher"]  
graph["mom"] = ["mom_friend", "mom_mart"]  
graph["friend"] = ["IU","student"]  
graph["teacher"] = ["student", "wife"]  
graph["mom_friend"] = []  
graph["mom_mart"] = []  
graph["IU"] = []  
graph["student"] = []  
graph["wife"] = []  

# 가수를 찾는 함수를 정의합니다.  
def search(name):  
 #큐를 선언하고 지인리스트를 담습니다.  
 search_queue = deque()  
 search_queue += graph[name]  

 searched = []  
 while search_queue:  
 #큐에서 자료를 하나 꺼냅니다.  
 person = search_queue.popleft()  
 # searched 리스트에 포함되어있지 않으면  
 if not person in searched:  
 # singer가 맞는지 확인합니다.  
 if find_singer(person):  
 print person + " is a Best Singer!"  
 return True  
 # singer가 아니면  
 else:  
 # 다음 단계 사람들은 큐에 추가합니다.  
 search_queue += graph[person]  
 # 중복 확인을 막기위해 searched 리스트에도 추가해줍니다.  
 searched.append(person)  
 return False  

search("start")  
```

##### [](#Result "Result")Result

```
IU is a Best Singer!  
```

너비 우선 탐색 알고리즘을 통해 우리는 아이유를 찾았습니다!  
이 탐색이 걸리는 시간은 내가 알고 있는 모든 관계의 수, 즉 O(간선의 갯수)가 됩니다.  
그런데 지인들을 모두 큐에 추가해야 하는 시간도 필요합니다.  
그래서 O(간선의 갯수+지인의 수)라고 할 수 있습니다. 이것을 기호로  
O(V+E)로 표현하며 V는 정점의 수, E는 간선의 수를 의미합니다.

##### [](#마치며… "마치며…")마치며…

어느덧 이 책도 절반의 내용은 끝났습니다.  
하지만 알고 있습니다. 아직도 알고리즘의 극히 일부만을 공부하고 있다는 것을.  
문제 풀이도 꾸준히하면서 공부해야겠습니다.

다음 포스팅은 다익스트라 알고리즘입니다.  
처음들어보는건데…?!

> Hello Coding 알고리즘, 아디트야 바르가바  
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.

