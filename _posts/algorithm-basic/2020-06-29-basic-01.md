---
layout: post
title: "[알고리즘-기초]01.빅오 표기법과 이진탐색"
date:   2020-06-29 13:50:21
categories: algorithm
---

### [](#빅오표기법 "빅오표기법")빅오표기법

프로그래밍에서 알고리즘은 프로그램의 실행속도의 큰 영향을 미칩니다.  
알파고가 수십, 수백만의 바둑기보를 저장하고 있으면서도 이세돌과의 바둑 경기에서  
빠르게 다음 수를 생각할 수 있었던건, 효율적인 알고리즘과 어마무시한  
컴퓨터 성능을 가지고 다음에 두어야 할 수를 찾기 때문입니다.

이처럼 프로그래밍 관점에서의 알고리즘은 얼마나 빠른 실행속도를 가지고  
있느냐가 관건인데요. 이를 표기할 수 있는 방법이 바로 `빅오표기법`이라고 합니다.

#### [](#기본구조와-예 "기본구조와 예")기본구조와 예

O(연산횟수 or 실행속도)  
맞습니다. 대문자 O를 사용해서 나타낸다고 하여 ‘빅오 표기법’입니다.  
여기서 연산횟수와 실행속도는 가장 빠를때가 아니라 가장 느릴때의 시간을  
나타냅니다.

예를들어 보겠습니다.  
100명이 저장된 카카오톡 친구목록에서 황씨 성을 가진 친구 한명을 찾아본다고 하죠.  
우리는 친구목록을 가,나,다 순으로 정리하였고 위에서부터 차례도 친구를 찾아 나갑니다.
만약 우리가 아래서부터 찾는다면 금방 찾겠지만 위에서부터 찾는다면 100명을  
모두 살펴봐야 할지도 모릅니다. 그래서 이때의 실행속도는 `O(100)`이 되게 됩니다.  
이렇게 차례로 하나씩 순서대로 탐색하는 방법을 `선형탐색`,`선형검색`이라고 합니다.

그럼 친구목록에서 친구를 좀 더 빠르게 찾을 수 있는 방법은 없을까요?  
그러한 방법 중 하나가 바로 `이진탐색`입니다.

#### [](#이진탐색 "이진탐색")이진탐색

우리는 알고 있습니다. 그저 친구이름을 검색해서 찾는것이 가장 빠른 방법이라고.  
하지만 이진탐색이 무엇인지 알아야하니 그 방법을 알아보겠습니다.

자 그럼 이제 컴퓨터에서 1~100까지의 숫자중 임의의 숫자 하나를  
찾아본다고 하겠습니다. 당신이 어떤 숫자를 이야기 했을때, 그 숫자가 찾으려는  
숫자보다 크거나 작다는 것을 컴퓨터가 알려준다고 합니다.  
만약 100이란 숫자를 결정했고 위에 말씀드린 바와같이 선형탐색을 통해  
1부터 찾아나간다면 컴퓨터는 계속 ‘더 크다’는 답변을 할테고
100번의 탐색이 이루어져야만 비로소 100을 찾아낼 수 있습니다.

이진탐색은 자료의 중간 부터 이야기하여 절반씩 탈락시키는 과정을 거칩니다.  
마찬가지로 100을 찾아보겠습니다.  
일단 50을 이야기합니다. ‘더 크다’  
75를 이야기 합니다. ‘더 크다’  
87을 이야기 합니다. ‘더 크다’  
94를 이야기 합니다. ‘더 크다’  
97을 이야기 합니다. ‘더 크다’  
99를 이야기 합니다. ‘더 크다’  
정답은 100입니다.

이렇게 이진탐색을 이용하여 답을 찾으면 최대 7번만에 답을 찾을 수 있습니다.  
빅오표기법을 사용하면 `O(7)`이 되겠네요.

100개의 자료를 두고 했을 떈, 선형탐색(100) -> 이진탐색(7)이지만  
자료의 양이 많아지면 많아질수록 더 극명한 결과의 차이를 보입니다.

1개의 데이터를 탐색할때 1밀리초가 걸린다고 가정하였을때  
비교한 표입니다.  

|자료수|선형탐색|이진탐색|  
|:--------:|:--------:|:--------:|
|100개|100밀리초|7밀리초|  
|10,000개|10초|14밀리초|  
|1,000,000,000개|11일|32밀리초|  
|n개|O(n)|O(log n)|

#### [](#구현 "구현")구현

##### [](#Example "Example")Example

```python
def binary_search(list, item):  
 # 탐색할 데이터의 사이즈를 확인하여 초기값을 셋팅합니다.  
 low = 0  
 high = len(list) - 1  

 # 일치하는 결과가 나올떄까지 반복합니다.  
 while low <= high:  
 # 중간값을 찾아 탐색합니다.  
 mid = (low + high) // 2  
 guess = list[mid]  
 # 일치하면 결과를 반환합니다.  
 if guess == item:  
 return mid  
 # 추측한 숫자가 더 크다면 high 값에 중간값을 담습니다.  
 if guess > item:  
 high = mid - 1  
 # 그렇지 않으면 low에 중간값을 담습니다.  
 else:  
 low = mid + 1  
 # 일치하는 결과가 없다면 None을 반환합니다.  
 return None  

my_list = [1, 3, 5, 7, 9] # 다음과 같은 리스트를 선언했습니다.  
print(binary_search(my_list, 3)) # => 1  
print(binary_search(my_list, -1)) # => None  
```

##### [](#Result "Result")Result

```
1  
None
```

#### [](#보너스-이야기 "보너스 이야기")보너스 이야기

`다르게 생각하는 연습`이라는 책에서 이진탐색과 비슷한 재미있는 일화를 소개해줍니다.  
당신이 만약 누군가에게 주식을 예언해주는 메일을 받았습니다.  
혹시나 해서 그 메일을 살펴보았고,  
그 메일에선 내일 XX전자의 주식이 오를거라고 예측했습니다.  
다음날 정말로 XX전자의 주식이 올랐습니다. 당신은 그저 우연이라고 생각했습니다.  
그리고 다시 메일이 왔습니다.  
이번엔 XX전자 주식이 떨어질것이라고 예측했습니다.  
그리고 어김없이 다음날 XX전자의 주식이 떨어졌습니다.  
그렇게 당신은 10번의 메일을 받았고 그 10번의 메일에서 예측한 주식의 결과는  
모두 정확했습니다. 과연 어떻게 된 일일까요?

이것도 일종의 이진탐색 알고리즘을 이용했다고 볼 수 있습니다.  
10번의 주식 예측을 맞출 수 있었던 이유는 10,000명에게 메일을 보냈기 때문입니다.  
먼저 10,000명을 5,000명씩 두 그룹으로 나눕니다.  
한쪽에는 XX전자 주식이 오를것이라고 예측하고, 나머지는 떨어질 것이라고 예측하여  
메일을 보냅니다. 만약 실제로 주식이 올랐다면 떨어질거라고 예측한 5,000명의 그룹은 버립니다.
그리고 적중한 5,000명을 대상으로 반반씩 그룹을 나눠 같은 메일을  
보내는 것이죠. 그럼 10번을 모두 맞추게 되는 그룹이 생길 수 밖에 없게됩니다.

그들에게는 저 예측자가 예언가처럼 보일 수 밖에 없겠네요.

##### [](#마치며… "마치며…")마치며…

재미있는 이야기와 함께 알고리즘 공부를 시작했습니다.  
책도 쉽고 재미있게 쓰여있는 것 같아 공부하기 좋은 것 같아요.  
다만 포스팅까지 같이 하려니 시간이 많이 드는건 사실이네요.  
시간날때 포스팅 열심히 달려야겠습니다.  
다음시간에는 `선택 정렬`에 대해 알아보도록 하겠습니다.

> blockquote Hello Coding 알고리즘, 아디트야 바르가바  
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.
