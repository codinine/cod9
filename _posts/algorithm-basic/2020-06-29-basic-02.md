---
layout: post
title: "[알고리즘-기초]02.선택정렬(feat.배열,리스트)"
date:   2020-06-29 13:50:39
categories: algorithm
---

### [](#배열과-연결-리스트 "배열과 연결 리스트")배열과 연결 리스트

선택 정렬을 이해하기 위해서는 먼저 배열과 리스트에 대한 이해가 필요합니다.  
배열, 리스트의 개념은 `자료구조(Data Structure)`의 관한 이야기인데,  
간단하게 정의하면 데이터를 어떻게 저장할 것인가에 대한 연구, 방법을 이야기합니다.

우리는 지하철 보관함에 물건을 보관하기로 했습니다.  
짐이 아주 많아서 3개의 보관함을 이용할 예정입니다.  
기억하기 쉽게 우리는 차례로 비어있는 3칸의 보관함에 물건을 보관했습니다.  
다음에 물건을 찾을때에도 순서대로 찾기만 하면 되니 물건을 찾기가 쉽겠죠?  
순서대로 물건을 보관하는 것, 이것이 `배열`입니다.

또 다른 예를 3개의 물건을 보관하기로 했는데 사람들이 많이 이용해서  
3개가 연속해서 비어있는 보관함이 없습니다. 그래서 어쩔 수 없이 우리는  
각각의 짐을 따로 보관하였습니다. 대신 다음 보관할 짐의 위치를 잊지 않기 위해  
첫번째 짐에는 다음 짐의 위치를, 두번쨰 짐에는 세번째 짐의 위치를 쪽지에 적어  
함께 보관하였습니다.  
이처럼 연속되어 보관되어있지는 않지만 하나의 보관함을 열어보면 다음 짐의 위치를  
알 수 있는 것이 `연결리스트`입니다.

컴퓨터도 마찬가지로 데이터를 저장하는 저장소가 있고, 각각 주소를 가지고 있습니다.  
우리는 그 주소에 데이터를 저장하게 되는데, 배열과 리스트의 방식을 이용할 수 있습니다.

배열의 장점은 저장된 데이터가 어떤 위치에 있는지 탐색이 쉽다는 것입니다.  
반대로 단점은 미리 공간을 확보해야하기 때문에 낭비하는 메모리가 발생할 수 있고  
데이터 사이의 추가/삭제가 불편하다는 점입니다.

리스트는 특정 데이터의 위치를 찾기 위해서는 첫번째 데이터부터 순차적으로  
위치를 찾아내야 한다는 것이 단점입니다.  
하지만 데이터 사이에 데이터를 추가하거나 삭제하는것이 용이합니다.

이를 빅오표기법을 이용하여 표로 나타내면 다음과 같습니다.  

| | 배열 | 리스트 |  
|:--------:|:--------:|:--------:|
|읽기|O(1)|O(n)|  
|삽입|O(n)|O(1)|  
|삭제|O(n)|O(1)|

결과적으로 어떤 방법이 더 좋다, 나쁘다가 아니라 상황에 따라 최적화된 저장방식을 사용하는 것이 좋겠습니다.

### [](#선택정렬 "선택정렬")선택정렬

핸드폰에 다음과 같은 가수가 있고 그 가수의 노래를 해당 횟수만큼 재생되었다고 하겠습니다.  

| 제목 | 재생횟수 |  
|:--------:|:--------:|
|아이유|89|  
|BTS|101|  
|트와이스|45|  
|박효신|76|  
|에이핑크|135|

이 가수의 목록들을 가장 많이 재생된 차례대로 정렬한다고 하겠습니다.  
(1) 아이유와 BTS를 비교한다.  
(2) 아이유를 트와이스와 비교한다.  
(3) 아이유와 박효신을 비교한다.  
(4) 아이유와 에이핑크를 비교한다.  
(5) 가장 큰 에이핑크를 가장 위에 배치한다.  
`1 Cycle 실행`  
(6) BTS를 에이핑크를 제외하고 차례로 비교한다.  
…

1등을 찾기 위해서는 빅오표기법으로 O(n-1) 시간이 걸린다는 것을 알 수 있습니다.  
2등, 3등, 4등을 찾을때마다 n-2, n-3, n-4 시간이 걸립니다.  
이를 모두 더하면 평균적으로 O(n(n-1)/2)이 됩니다.  
하지만 빅오표기법 방식에 의하면 상수항들은 무시한다고 합니다.  
그래서 최종적으로는 O(n^2^)이 됩니다.

#### [](#구현 "구현")구현

##### [](#Example "Example")Example

{% codeblock lang:python %}
def sel_sort(a):  
 n = len(a) #리스트의 길이를 체크합니다.  
 for i in range(0, n - 1): # n-1 번만큼 비교합니다.  
 min_idx = i  
 for j in range(i + 1, n): # 비교횟수를 1번씩 감소합니다.  
 if a[j] < a[min_idx]: # 가장 작은 수를 찾아 비교합니다.  
 min_idx = j # 작으면 해당인덱스를 min_idx에 넣고  
 a[i], a[min_idx] = a[min_idx], a[i] # 값을 교체합니다.  
 print(a)     # 정렬 과정 출력하기  

d = [2, 4, 5, 1, 3]  
sel_sort(d)  
print(d)  
{% endcodeblock %}

##### [](#Result "Result")Result

{% codeblock %}
[1, 4, 5, 2, 3]  
[1, 2, 5, 4, 3]  
[1, 2, 3, 4, 5]  
[1, 2, 3, 4, 5]  
[1, 2, 3, 4, 5]  
{% endcodeblock %}


##### [](#마치며… "마치며…")마치며…

책의 초반부인데도 정확하게 이해하는게 쉽지는 않네요.  
이떄까지 알고리즘 허투루 배웠나봅니다.

느리지만 천천히 정확하게 하도록 해야겠습니다.  
다음 포스팅에서는 재귀에 대해서 알아보도록 하겠습니다.

{% blockquote Hello Coding 알고리즘, 아디트야 바르가바 %}
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.
{% endblockquote %}
