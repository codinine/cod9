---
title: "[알고리즘-기초]09.동적프로그래밍(동적계획법)"
date: 2019-04-15 14:20:18
categories:
- Algorithm
- 기초
---

#### [](#배낭-채우기-문제 "배낭 채우기 문제")배낭 채우기 문제

지난번 예를 들었던 배낭 채우기 문제를 조금 더 들여다 보겠습니다.  
당신을 5kg을 담을 수 있는 가방이 있습니다.

담을 수 있는 물건은 총 3가지 입니다.

1.  노트북 5kg - 100만원
2.  핸드폰 1kg - 50만원
3.  바이올린 4kg - 80만원

가장 높은 금액이 되도록 담아야합니다.  
가장 단순한 방법은 모든 경우의 수를 비교해 보는 것입니다.  
이 경우 물건의 갯수가 많아지게되면 경우의 수가 기하급수적으로 증가합니다.  
물건이 32개인 경우 약 40억개의 경우의 수가 나옵니다.

그렇다면 다른 해결방법을 알아보도록 하죠.  
바로 격자를 활용하는 방법입니다.

![](/images/algorithm-basic-09_1.jpg)

각각의 물건이 차지하는 비중에 그때의 최대값을 찾아나가는 방식입니다.  
다른 공간에 물건이 들어올 수 있는 경우를 파악해서 최대값을 갱신하게 되면  
그 값을 교체하게 됩니다.

이 방법은 상품의 위치를 변경하거나 추가하더라도 동일한 결과를 만들 수 있다고 합니다.  
이러한 방법을 `동적계획법(Dynamic Programming)`이라고 합니다.  
코드로는 이중배열을 활용하여 구하는데 책에서는 정확한 예제를 제공하고 있지 않습니다.

그래서 구글링 하여 비슷하게 구현된 예제가 있어서 가져왔습니다.

#### [](#구현 "구현")구현

출처 : [http://sweetdays.tistory.com/46](http://sweetdays.tistory.com/46)

##### [](#Example "Example")Example

{% codeblock lang:python %}
# Sample input  
#N, W = 4, 5  
#J = [[2, 40], [5, 110], [10, 220], [3, 50]]  
# Input  
# 입력받을 갯수 N개와 최대값을 구할 영역 W(최대가중치) 입니다.  
# 그 밑으로는 N번 만큼 x를 입력받는데, (가중치 무게) 형태로 입력합니다.  
# 입력한 값은 J라는 리스트에 저장됩니다.  
N, W = map(int, input().split(' '))  
J = []  
for i in range(N):  
 J.append([int(x) for x in input().split(' ')])  

# C는 우리가 담을 배낭입니다.  
C = []  
# 최대 가중치 만큼 반복합니다.  
for w in range(W+1):  
 maxCost = 0  

 for i in range(N):  
 # J에 저장되 있는 값들을 하나씩 뽑아보며 maxCost 보다 큰지 확인합니다  
 # 크다면 해당 값을 maxCost에 저장합니다.  
 if w - J[i][0] >= 0 and C[w-J[i][0]] + J[i][1] > maxCost:  
 maxCost = C[w-J[i][0]] + J[i][1]  
 # 그렇게 구해진  maxCost 값을 배낭에 저장합니다.  
 C.append(maxCost)  
print(C)  
{% endcodeblock %}

##### [](#Result "Result")Result

{% codeblock %}
[0, 0, 40, 50, 80, 110] # 위의 샘플대로 입력했을 경우 다음과 같은 결과가 나옵니다.  
{% endcodeblock %}

#### [](#최장-공통-부분-문자열 "최장 공통 부분 문자열")최장 공통 부분 문자열

말이 뭔가 어렵습니다. 검색엔진을 사용할 때, 우리는 오타를 흔히 내곤 합니다.  
한글을 영문 그대로 친다던지, 맞춤법이 틀리다던지. 그럴때 검색엔진은 신기하게도  
**개떡같이 이야기한걸 찰떡 같이 알아듣습니다.** 자체적으로 사용자가 검색하고자했던  
단어나 문장을 알고리즘을 통해 찾아내기 때문입니다.  
이때 사용하는 것을 `최장 공통 부분 문자열`이라고 합니다.

잘 못 쓰여진 글자와 올바른 문자를 비교하여 얼마나 일치하는지 탐색하는 방법이죠.  
위와 마찬가지로 동적계획법 형태로 구현합니다.  
격자를 활용해 일치하는 정도에 따라 가중치로 표현합니다.  
깔끔하게 제공된 예제 소스를 통해 살펴보도록 하겠습니다.

#### [](#구현-1 "구현")구현

##### [](#Example-1 "Example")Example

{% codeblock lang:python %}
word_a = 'fish'  
word_b = 'cash'  
# 글자수 만큼 배열을 할당합니다.  
cell = [[0]\*len(word_a) for i in range(len(word_b))]  
for i in range(len(word_a)):  
 for j in range(len(word_b)):  
 # word_a의 첫글자부터 word_b의 글자들을 각각 비교합니다.  
 if word_a[i] == word_b[j]:  
 #일치하면 가중치를 증가시키고  
 cell[i][j] = cell[i-1][j-1] + 1  
 else:  
 #그렇지 않으면 이미 비교했던 값들의 최대값을 저장합니다.  
 cell[i][j] = max(cell[i-1][j], cell[i][j-1])  
print(cell)  
{% endcodeblock %}

##### [](#Result-1 "Result")Result

{% codeblock %}
# 첫글자, 두번쨰 글자는 어디에도 일치하지 않으니 0을 반환합니다.  
# 세번째 글자는 세번째 글자부터 일치하니 1, 1 을 반환했네요.  
# 네번쨰 글자 h는 cash 네번째 글자와 일치합니다. 그래서 마지막에 2를 반환합니다.  

[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 1, 1], [0, 0, 1, 2]]  
{% endcodeblock %}

##### [](#마치며… "마치며…")마치며…

책의 후반부를 진행하고 있는데, 정말 어렵네요.  
정말 어려운 알고리즘들을 보면 삼각함수, 미적분도 활용하던데 이쯤되면  
이것이 프로그래밍인지 수학인지 모르겠네요.

위의 코드는 최적화된 코드가 아닐 수 있으며,  
조건에 따라 충분히 바뀔 수 있음을 알려드립니다.

다음시간에는 KNN 알고리즘 k-최근접 이웃 알고리즘을 알아보겠습니다.  
소스는 없고 개념적인 부분들만 있으니 편하게 읽어주셔도 될 것 같네요.

{% blockquote Hello Coding 알고리즘, 아디트야 바르가바 %}
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.
{% endblockquote %}
