---
layout: post
title: "[알고리즘-기초]08.탐욕 알고리즘과 NP-완전문제"
date:   2020-06-29 13:50:29
categories: algorithm
---

#### [](#탐욕-알고리즘 "탐욕 알고리즘")탐욕 알고리즘

탐욕 알고리즘은 의미와 같이 이해한다면 어렵지 않습니다.

|수업|시작|종료|
|:--------:|:--------:|:--------:|
|국어|오전09:00|오전10:00|
|수학|오전09:30|오전11:00|
|영어|오전10:00|오전11:00|
|미술|오전10:00|오전12:00|
|체육|오전11:00|오전12:30|

다음과 같은 수업 시간표가 있습니다.  
우리는 가능한한 많은 수업을 들으려고 합니다. 당연히 수업시간이 겹치면 안되겠죠.  
그럼 우리는 가장 빨리 시작해서 가장 빨리 끝나는 수업을 찾습니다.  
국어를 선택하겠습니다.  
마찬가지로 국어가 끝나는 10시부터 가장 빨리 끝나는 수업을 찾습니다.  
영어네요. 그 다음은 체육을 들으면 되겠군요.  
최대 3개의 수업을 들을 수 있습니다.

비슷한 예를 하나 더 들어보겠습니다.  
우리에게 5kg을 담을 수 있는 가방이 있습니다. 가장 비싼 물건들로 채우려고 합니다.

1.  노트북 5kg - 100만원
2.  핸드폰 1kg - 50만원
3.  바이올린 4kg - 80만원

가장 비싼건 노트북 이므로 1번을 고르게 될 겁니다.  
하지만 2,3을 같이 넣으면 노트북(100만원)가격보다 더 비싸다는 걸 알 수 있습니다.  
이것이 탐욕 알고리즘이 가지고 있는 오류입니다.

그럼에도 불구하고 탐욕 알고리즘이 반드시 필요한 경우가 있습니다.

#### [](#집합-커버링-문제 "집합 커버링 문제")집합 커버링 문제

아래와 같이 배달 가게의 배달 가능 지역을 구분해 놓았습니다.

|가게|지역|
|:--------:|:--------:|
|중국집|종로구 동대문구 서대문구|
|떡볶이|동대문구 송파구 강동구|
|족발|강서구 강남구 동작구|
|치킨|마포구 강서구 구로구|
|피자|노원구 성북구 중랑구|

가장 적은 가게를 선택하여 모든 구역에서 배달이 가능하도록 해야합니다.  
메뉴가 중요한건 아니죠.  
그럼 이들이 가지고 있는 모든 부분집합을 알아봐야하기 떄문에  
O(2^n^) 시간이 걸립니다. 가게와 지역이 많아질수록 급격하게 시간이 증가합니다.  
이때 근사치를 구하기 위해 탐욕 알고리즘을 사용합니다.

모든 경우의 수를 알아보는 것이 아니라 하나, 하나 대입을 하며 원하는 결과가 나올때까지  
반복하는 방법을 이용합니다.  
코드를 통해 알아보겠습니다.

#### [](#구현 "구현")구현

##### [](#Example "Example")Example

```python
# 한글이 깨져서 import 하였습니다.  
import sys  
import io  
sys.stdout = io.TextIOWrapper(sys.stdout.detach(), encoding = 'utf-8')  
sys.stderr = io.TextIOWrapper(sys.stderr.detach(), encoding = 'utf-8')  

# 원하는 결과를 셋팅합니다.  
states_needed = set(["종로", "동대문", "서대문", "송파", "강동", "강서", "강남", "동작"])  

# 가게별 배달 지역을 셋팅합니다.  
stations = {}  
stations["중국집"] = set(["종로", "동대문", "서대문"])  
stations["떡볶이"] = set(["동대문", "송파", "강동"])  
stations["족발"] = set(["강서", "강남", "동작"])  
stations["치킨"] = set(["강동", "강서"])  
stations["피자"] = set(["송파", "종로"])  

final_stations = set()  

# states_needed의 값이 존재하지 않을때까지 반복합니다.  
while states_needed:  
 best_station = None  
 states_covered = set()  
 for station, states in stations.items():  
 # states_needed 과 states 의 교집합을 구합니다. ( &연산자 입니다.)  
 # 교집합의 길이가 데이터를 저장할 states_covered의 길이보다 길다면  
 # 해당 가게를 best_station에 저장하고 해당 지역은 states_covered에 저장합니다.  
 covered = states_needed & states  
 if len(covered) > len(states_covered):  
 best_station = station  
 states_covered = covered  

 # 해당 지역은 제외하고 final_stations에 가게 이름은 넣어줍니다.  
 states_needed -= states_covered  
 final_stations.add(best_station)  

print(final_stations)  
```

##### [](#Result "Result")Result

```
{'족발', '중국집', '떡볶이'}  
```

#### [](#NP-완전문제 "NP-완전문제")NP-완전문제

NP-완전문제란 정확한 정답을 가진 알고리즘이 없는 문제를 이야기합니다.  
정답이 없으니 상당히 난해할 수 밖에 없습니다. 보통 어려우면 설명을 안하고 넘어가는데  
왠지 중요해보여서 언급을 해야하지 않나 싶었습니다.

우리가 시작점을 모르는 2개의 지역을 다 둘러볼 수 있는 방법의 가지 수는 모두 2가지 입니다.  
예를 들어 서울, 부산이라 하면 서울에서 부산으로, 부산에서 서울로 2가지죠.  
이런 방식으로 3개의 지역이라면 6가지, 4개의 지역이라면 24가지가 됩니다.  
O(n!)시간이 걸리며 팩토리얼 함수의 형태로 경우의 수가 늘어납니다.  
그런데 이 지역들을 방문하는데 가장 최적화된 경로를 찾기 위해서는 모든 경우의 수를  
다 파악해보는 수 밖에 없다고 합니다. 10개의 도시만 되도 300백만개가 넘는데 말이죠.

그래서 이 문제 역시 정확한 정답을 구할 순 없지만 근사화를 통해 문제를 해결해야합니다.  
임의의 도시를 1개를 선정한 후 그곳에서 가장 짧은 거리에 있는 도시들을 찾아 차례로 연결하는 것이죠.  
정답은 아니겠지만 그래도 상당히 빠른 알고리즘이 될 것 입니다.

#### [](#NP-완전문제-판별법 "NP-완전문제 판별법")NP-완전문제 판별법

문제를 완벽하게 해결하는 알고리즘이 없는 만큼, NP-완전문제를 판별할 수 있는 명확한 방법 또한  
없다고합니다. 하지만 몇가지 참고사항을 통해 우리는 이것이 NP-완전문제인지 파악할 수 있습니다.

1.  항목이 늘어나면서 급격이 느려질때
2.  ‘모든 조합’을 염두해 두어야할때
3.  재귀 또는 더 작은 범위로 분할 할 수 없을때
4.  문제가 수열을 포함하고, 풀기가 어려울때
5.  집합이 있고, 풀기가 어려울때
6.  외판원 형태의 문제일때

##### [](#마치며… "마치며…")마치며…

개념적으로 상당히 어려울 수 있는 알고리즘이었습니다.  
이 정도되니 도대체 이것들은 언제 어디서 써먹는 것일까 하는 생각이 듭니다.  
하지만 처음에 이야기했듯이 반드시 사용하지 않더라고 컴퓨터적인 사고를 기르기 위해서는  
필수이니 남은 것들도 열심히 공부해보도록 하겠습니다.

> Hello Coding 알고리즘, 아디트야 바르가바  
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.

