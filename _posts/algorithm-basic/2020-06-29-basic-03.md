---
layout: post
title: "[알고리즘-기초]03.재귀(feat.스택)"
date:   2020-06-29 13:50:39
categories: algorithm
---

### [](#재귀 "재귀")재귀

재귀란 `원래의 자리로 돌아감`이라는 사전적의미를 가지고 있습니다.

![](/images/algorithm-basic-03_1.jpg)  
러시아의 전통 인형 마트료시카를 알고 계신가요?  
인형안에 인형 또 인형안에 인형이 있는 형태입니다.  
`재귀`를 아주 쉽게 표현한 방법이라고 할 수 있습니다.

보통 프로그래밍에서 재귀는 함수의 형태로 구현되며  
함수 내에서 자기 자신을 다시 호출하는 구조로 되어있어, 특정 조건이  
닿을때까지 계속해서 자기 자신을 호출하도록 되어있습니다.

반대로 이야기하면 특정 조건이 존재하지 않으면 재귀함수는 무한루프에 빠져들게 됩니다. 그래서 재귀함수를 구현할때에는 반드시 조건, 제어을 통해 함수를 종료시켜야 합니다.

### [](#스택 "스택")스택

지난 번에 `선택정렬`을 이해하기 위해서 `배열`과`리스트`라는 자료구조를  
알아봤었습니다. 재귀를 이해하기 위해서는 `스택`이라는 자료구조를 이해하는 것이  
중요합니다.

`스택`은 데이터가 먼저들어간 것이 나중에 나오는 구조를 가지고 있습니다.  
예를들어, 엘리베이터에 순서대로 탑승했을때, 마지막에 탄 사람이 내릴때는  
가장 먼저 내리게 되는 것처럼 말이죠. (모두 같은 층에서 타고, 같은 층에서 내리는 것으로 가정했을때)  
그래서 스택을 선입후출(Last In First Out) 구조라고 합니다.  
스택에 데이터가 들어가는 것을 Push, 데이터가 나오는 것을 Pop 이라고 합니다.

그럼 이 스택이라는 자료구조가 재귀와 어떤 관련이 있는지 예제를 통해  
알아보도록 하겠습니다.

#### [](#구현 "구현")구현

간단한 팩토리얼 함수입니다.  
이 재귀함수의 구조의 흐름을 손으로 직접써보는 것도 도움이 많이 됩니다.

##### [](#Example "Example")Example

{% codeblock lang:python %}
def fact(x):  
 if x == 1:  
 return 1  
 else:  
 return x * fact(x\-1)  

print(fact(5))  
{% endcodeblock %}

##### [](#Result "Result")Result

{% codeblock %}
120
{% endcodeblock %}


(1) fact(5) 호출  
(2) else: 뒤의 fact(4) 호출  
(3) else: 뒤의 fact(3) 호출  
(4) else: 뒤의 fact(2) 호출  
(5) if: 뒤의 return 1 반환  
(6) 1 * 2  
(7) 1 * 2 * 3  
(8) 1 * 2 * 3 * 4  
(9) 1 * 2 * 3 * 4 * 5

fact(5) 호출 되었지만 fact(4),… 뒤늦게 호출된 함수들이 모두 실행되고  
난 후 마지막에 fact(5) 함수가 종료된다는 것을 알 수 있습니다.

재귀함수를 구현하고 있으면서 `스택`형태의 자료구조를 이용하고 있다고 볼 수  
있습니다.  
하지만 이 방법을 쓰면 숫자가 커질 경우, 엄청난 메모리를 사용합니다.  
이럴때 파이썬에서는 `메모화`라는 방법을 사용한다고 파이썬 기초 포스팅에서  
말씀드린 적이 있습니다.

[파이썬-기초_14.함수(2) - 리턴값과 재귀함수](https://codinine.github.io/2018/11/13/python-basic-20181113-14/)

##### [](#마치며… "마치며…")마치며…

벌써 배운 것들이 연결되기 시작하네요. 그래서 더 재미있는 것 같습니다.  
학교 다닐때보다도 지식을 체계적으로 적립해 나가는 것 같네요.  
역시 배움에는 끝이 없나봅니다.

다음 포스팅에선 퀵 정렬에 대해 알아보겠습니다.

{% blockquote Hello Coding 알고리즘, 아디트야 바르가바 %}
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.
{% endblockquote %}
