---
title: "[알고리즘-기초2]8.글로만 구현하는 알고리즘 - 정렬편(2)"
date: 2019-04-18 14:38:18
categories:
- Algorithm
- 기초
---

#### [](#셸-정렬 "셸 정렬")셸 정렬

셸 정렬은 서로 이웃한 데이터들을 정렬하는 것이 아니라  
일정한 간격을 두고 그 데이터들을 그룹으로 묶어 정렬하는 방법이다.

정렬되지 않은 12개의 데이터가 있다고 가정한다.  
처음에는 N/2, 즉 6으로 간격을 정한다.  
첫번째 데이터는 7번째 데이터와  
두번째 데이터는 8번째 데이터와  
이런식으로 비교하여 정렬하는 것이다.

그 후에는 N/4, 즉 3개의 데이터가 그룹이 된다.  
이때는 [1,5,9] 데이터를 비교하고  
[2,6,10][3,7,11][4,8,12] 이렇게 비교하여 정렬한다.  
그룹을 점점 키워나가면 최종적으로 각각의 데이터들을 비교하게 되는데  
위의 작업으로 대부분 정렬이 되어 있는 상태라 이동횟수가 크게 줄어들게 된다.

#### [](#병합정렬 "병합정렬")병합정렬

병합 정렬은 조금 더 복잡한 데이터 형태를 가진 값들을 정렬할때 사용한다.  
여러개의 데이터 배열이 있다고 가정한다. 이것을 정렬된 하나의 배열 공간에  
저장을 하려고 한다. 그럼 먼저 각각의 배열을 정렬해야한다. 그 후에는  
각 배열의 첫번째 요소들을 비교하여 가장 작은 수를 새로운 배열에 저장한다.  
그 후 다시 각 배열의 첫번쨰에 있는 요소들을 비교하여 작은 수부터 차례로  
새로운 배열에 저장한다.

반대로 정렬되어있는 않은 하나의 배열을 여러개로 나누기도 하는데 이때는  
‘분할’한다고 한다. 병합과 반대되는 개념이다.

#### [](#퀵-정렬 "퀵 정렬")퀵 정렬

이름처럼 빠르다고하여 퀵 정렬이다.  
퀵 정렬은 정렬되지 않은 데이터들 중에 기준이 되는 값을 하나 정하여  
기준 값보다 작으면 왼쪽 크면 오른쪽에 배치한다.  
왼쪽에 정렬되지 않은 값들을 위와 같은 방법으로 기준값을 정하여 정렬하고  
마찬가지고 오른쪽에 있는 값들도 동일한 작업을 한다.  
단순 교환 정렬, 단순 삽입 정렬보다는 훨씬 빠른 처리속도를 가지고 있다.

하나의 가벼운 동전 찾기 문제도 퀵 정렬이 활용되었다고 할 수 있다.  
8개의 동전 중 단 한개의 동전만 가볍다고 해보자. 그 동전을 찾기 위해  
양팔 저울을 사용하는 최소 횟수는 몇번일까?

8개의 동전을 먼저 3개, 2개, 3개의 그룹으로 나눈다.  
3개의 그룹 동전의 무게를 양쪽에 올려 잰다. 수평이 되면 남은 2개의 동전 무게를  
재어 가벼운 동전을 알 수 있고. 한쪽으로 기울어지면 가벼운 쪽 3개의 동전으로  
무게를 재는데 양쪽에 1개씩만 올리면 된다. 만약 수평이 되면 무게를 재지 않은  
하나가 가벼운 동전이고 한쪽으로 기운다면 올라간 쪽이 가벼운 동전이 된다.  
결국 8개의 동전 중 가벼운 동전을 찾는 것은 단 2번의 저울만 사용하면 된다.

#### [](#힙-정렬 "힙 정렬")힙 정렬

힙 정렬은 데이터를 힙 형태로 만들어 힙이 가지고 있는 특징인  
부모는 자식 노드의 값보다 항상 크다는 성질을 가지고 정렬하는 방식이다.

구현하는 방식이 상당히 복잡하다.  
Step 1. 정렬되지 않은 데이터 N[k]가 있다.  
Step 2. i = k/2, T=i 로 초기화 한다.  
Step 3. i > 0 일때, 반복하는 반목문을 만든다.  
Step 4. N[T], N[2T], N[2T+1]의 값을 비교한다.  
Step 5. N[T]이 최대일때, i = i-1 , T=i로 한다.  
N[2T]이 최대일때, N[T]와 N[2T]의 값을 교환하고 T=2T로 한다.  
N[2T+1]이 최대일때, N[T]와 N[2T+1]의 값을 교환하고 T= 2T+1로한다.  
N[2T],N[2T+1]이 없으면 i = i-1 , T=i로 한다.

반복이 종료되면 N[k]를 반환한다.

{% blockquote 그림으로 배우는 알고리즘, 스기우라 켄 %}
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.
{% endblockquote %}
