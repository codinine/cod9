---
title: "[알고리즘-기초2]7.글로만 구현하는 알고리즘 - 정렬편(1)"
date: 2019-04-18 14:36:18
categories:
- Algorithm
- 기초
---

#### [](#정렬이란 "정렬이란?")정렬이란?

데이터를 순서를 가지고 나열하는 것이다.  
작은 순서대로 나열하는 것을 ‘오름차순’  
큰 순서대로 나열하는 것을 ‘내림차순’이라 한다.

#### [](#버킷정렬 "버킷정렬")버킷정렬

버킷정렬은 이름과 같이 충분한 수의 양동이를 준비하여  
적절하게 각각의 양동이에 데이터를 담을 것을 의미한다.

정렬되지 않은 여러개의 데이터들 중 최대값을 기준으로  
그와 동일한 크기만큼의 양동이(배열)를 준비한다.

모든 양동이는 비어있는 값으로 초기화한다.  
각각의 데이터는 양동이(배열)의 인덱스와 동일한 위치에 저장한다.

값이 들어있는 양동이를 반환하면 오름차순으로 정렬이 되게 된다.

Step 1. 배열 bucket[n]을 empty로 초기화한다.  
Step 2. k=0 부터 DATA의 최대값-1 까지 반복하는 반복문을 만든다.  
Step 3. VALUE = DATA[k] 를 담고 bucket[VALUE] = VALUE 를 담는다.  
Step 4. 반복문이 종료되면 bucket[]을 반환한다.

*   이 정렬 방법의 문제점은 데이터 값의 범위를 알아야한다는 거.

#### [](#기수정렬 "기수정렬")기수정렬

자리수가 많은 숫자들을 정렬해야하는 경우엔 어떻게 해야할까?  
3자리 숫자만 한다 하더라도 최대 1000개의 양동이(배열)이 필요하다.

이런 방법을 해결하려면 각 자리수만을 가지고 버킷정렬을 실행하면 된다.  
3자리의 숫자들을 비교한다면 3번의 버킷정렬을 실행하면 된다.  
단, 양동이는 여러개의 데이터를 닮을 수 있어야 한다.  
낮은 자리에서 높은 자리로 비교하고 왼쪽에서 오른쪽으로 데이터를 저장한다.

마지막 양동이에서 차례대로 데이터를 꺼내면 오름차순으로 정렬이 되게 된다.

Step 1. 각 데이터들의 1의 자리를 기준으로 버킷정렬한다.  
Step 2. 위에 담겨진 데이터의 순서대로(0~9)로 10자리를 가지고 다시 버킷정렬한다.  
Step 3. 위와같은 방법으로 N의 자리까지 버킷정렬한다.  
Step 4. 종료되면 왼쪽부터 데이터를 반환한다.  
(같은 양동이에 들어있는 데이터의 경우 먼저 들어온 데이터를 반환한다.)

#### [](#단순-선택-정렬 "단순 선택 정렬")단순 선택 정렬

이 방법은 말그대로 아주 단순하다. 정렬되지 않은 데이터들을 전부 탐색하여  
가장 작은 값을 가장 앞에 있는 값과 교환하는 방식이다.  
그 다음 작은 값은 두번째 앞에 있는 값과 교환한다.

뒤에는 나오는 정렬 방법들에 비해 비용이 많이 들어가는 정렬 방법으로  
단순하지만 효율은 매우 떨어지는 방법이다.

Step 1. 정렬되지 않은 부분에서 최소값을 찾는다.  
Step 2. 최소값을 1번째 요소와 교환한다.  
Step 3. 다시 정렬되지 않은 부분에서 최소값을 찾고 2번쨰 요소와 교환한다.  
Step 4. 위와 같은 Step을 N-1번(정렬되지 않은 부분의 요소가 1이 될때까지) 반복한다.

#### [](#버블-정렬-단순-교환-정렬 "버블 정렬(단순 교환 정렬)")버블 정렬(단순 교환 정렬)

단순 선택 정렬보다는 탐색의 횟수는 적은 정렬 방법이다.  
교환 횟수는 단순 선택 정렬보다는 많을 수 있다.  
정렬되지 않은 숫자들의 데이터를 첫번째 부터 이웃하는 데이터들을  
서로 비교하여 작으면 왼쪽 크면 오른쪽에 배치하는 것이다.

차례로 비교하며 교환하다 보면 오름차순 정렬이 되게 되는 정렬 방식이다.  
왼쪽에서부터 차례로 비교/교환하게 되면 가장 오른쪽에는 반드시 가장 큰 수가 오게된다.

최대값이 서서히 뒤로 옮겨지는 모습이 마치 사이다의 거품이 올라오는 모습과 비슷하다하여  
버블 정렬이라 불리게 되었다.

Step 1. 정려로디지 않은 부분에 1번째와 2번째 데이터를 비교한다.  
Step 2. 1번째 데이터 > 2번째 데이터라면 값을 교환한다.  
Step 3. 한칸 오른쪽으로 옮겨 다시 위와 같이 비교/교환한다.  
Step 4. 1 사이클이 완료되면 Step1~Step3을 반복의 횟수는 한번씩 줄이면서 반복한다.

#### [](#단순-삽입-정렬 "단순 삽입 정렬")단순 삽입 정렬

단순 삽입 정렬은 앞의 위치한 데이터들과 비교하여 비교한 데이터가 들어갈  
공간을 찾아 삽입 정렬하는 방법이다.  
새치기 하는 모습을 생각하면 이해하기 쉽다.  
데이터가 중간에 삽입이 되면서 나머지 데이터들은 뒤로 한칸씩 밀리게 된다.

Step 1. 반복 횟수 수행을 정할 k를 0으로 초기화한다.  
Step 2. k < i(비교할 데이터의 수)일 동한 반복할 반복문장을 만든다.  
Step 3. D[k] > D[i] 이면 반복을 종료한다.  
Step 4. D[i]를 W에 임시 저장한다.  
Step 5. D[k] ~ D[i-1]을 한칸씩 이동한다.  
Step 6. D[k]에 w 값을 저장한다.

{% blockquote 그림으로 배우는 알고리즘, 스기우라 켄 %}
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.
{% endblockquote %}
