---
layout: post
title: "[알고리즘-기초]07.다익스트라 알고리즘"
date:   2020-06-29 13:50:28
categories: algorithm
---

#### [](#다익스트라-알고리즘 "다익스트라 알고리즘")다익스트라 알고리즘

지난 포스팅에서 이야기했던 `너비 우선 탐색`알고리즘은 목표한 데이터를 찾기 위해  
최소의 단계를 거쳐 가는 방법을 알아내는 알고리즘이었습니다.  
`다익스트라 알고리즘`은 노드를 이동하는 `간선(edge)`에 `가중치(weight)`를 두어  
최소의 단계가 아니라 최적의 단계를 찾아내는 방법이라고 할 수 있습니다.

예를 들어 집에서 학교까지 걸어가는 방법이 2가지가 있다고 가정하겠습니다.

1.  집 -(5km)-> 우체국 -(4km)-> 학교
2.  집 -(2km)-> 동사무소 -(2km)-> 마트 -(3km)> 학교

1번의 경우처럼 집에서 우체국을 거쳐 학교에 갈 경우엔 9km이고,  
2번은 7km 걸리게 됩니다. 단계는 1번이 적지만 거리는 2번이 더 가깝습니다.  
다익스트라 알고리즘은 단계와 상관없이 목적지까지 가는 최소시간(여기서는 거리)을 찾아냅니다.

너비 우선 탐색에서 보았던 가중치가 없는 그래프를 `균일 그래프`  
다익스트라 알고리즘과 같이 가중치가 있는 그래프를 `가중 그래프`라고 합니다.

#### [](#다익스트라-알고리즘을-통한-물물-교환 "다익스트라 알고리즘을 통한 물물 교환")다익스트라 알고리즘을 통한 물물 교환

이제부터 헷갈리는 이야기가 될 수 있습니다. 정리를 잘 해보도록 하죠.  
친구와 물물교환을 하기로 했습니다.  
내가 내 놓은 물건은 `볼펜 1자루`입니다. 친구는 `텀블러`를 내놓았습니다.  
친구는 말 합니다. ‘텀블러와 바꾸고 싶다면 만원 더 내놔’  
그리고 친구는 또 다른 물건을 내놓습니다. `고급 게이밍 마우스`와 `기계식 키보드`입니다.  
‘마우스랑 바꾸려면 텀블러+3만원을 더 내고, 키보드랑 바꾸려면 볼펜+5만원을 더 줘야되’  
그리고 마지막으로 친구는 `플레이스테이션4`를 가지고 오며 말합니다.  
‘이거랑 바꾸려면 마우스+20만원이고, 키보드+17만원 줘야되’  
‘아, 그리고 참고로 마우스에서 키보드로 바꾸는건 2만원인거 알지?’  
**‘이 새끼 정말 물물교환 할 생각이 있는건지, 의심이 듭니다.’**  
하지만 우리는 가장 저렴하게 PS4를 확보할 방법을 알아내야 합니다.

![](/images/algorithm-basic-07_1.jpg)  
플스를 갖겠다는 집념으로 우리는 다음과 같은 표를 작성할 수 있었습니다.  
볼펜에서 시작해서 플스4로 가는 가장 금액이 적은 길을 찾아야만 합니다.

먼저 볼펜->키보드로 가는 경로를 보겠습니다. (만원 단위는 생략합니다.)

1.  볼펜 -(5)-> 키보드
2.  볼펜 -(1)-> 텀블러 -(3)-> 마우스 -(2)-> 키보드

1번은 5만원, 2번은 6만원이 들어갑니다. 키보드 경로는 1번이 가장 효율적이네요.  
마우스나 텀블러로 가는 경로는 오직 1가지 밖에 없으니 선택에 여지가 없습니다.  
그럼 PS4로 가는 경로를 보겠습니다. PS4로 가기 위해서는 반드시 키보드 또는 마우스를 지나쳐야합니다.  
그럼 다음과 같은 경로를 생각해 볼 수 있습니다.

1.  볼펜 -(5)-> 키보드 -(17)-> PS4
2.  볼펜 -(1)-> 텀블러 -(3)-> 마우스 -(20)-> PS4

아까 살펴봤던 마우스를 거쳐 키보드로 가는 경우는 고려대상이 아닙니다. 이미 볼펜에서 키보드로 직접가는  
경로보다 비싸다는걸 확인했기 때문이죠.  
그렇다면 최종적으로 1번은 22만원 2번은 24만원이 됩니다.  
키보드로 바꾼 후 플스4로 바꾸는 것이 가장 저렴한 방법임을 알게 됩니다.  
**플스 얻기 드릅게 힘드네**

#### [](#구현 "구현")구현

그럼 이제 드디어 다익스트라 알고리즘을 소스코드로 구현해볼 차례입니다.

##### [](#Example "Example")Example

```python
# 딕셔너리를 셋팅합니다.  
graph = {}  
graph["start"] = {}  
graph["start"]["a"] = 6 #시작에서 a로 가는건 6  
graph["start"]["b"] = 2 #시작에서 b로 가는건 2  

graph["a"] = {}  
graph["a"]["fin"] = 1 #a에서 fin으로 가는건 1  

graph["b"] = {}  
graph["b"]["a"] = 3 #b에서 a로 가는건 3  
graph["b"]["fin"] = 5 #b에서 fin으로 가는건 5  

graph["fin"] = {}  

# 첫 출발 비용 셋팅  
infinity = float("inf")  
costs = {}  
costs["a"] = 6  
costs["b"] = 2  
costs["fin"] = infinity # 결과를 알 수 없으므로 초기값을 무한대로 설정합니다.  

# 시작  
parents = {}  
parents["a"] = "start"  
parents["b"] = "start"  
parents["fin"] = None  

processed = []  

def find_lowest_cost_node(costs):  
 lowest_cost = float("inf")  
 lowest_cost_node = None  
 for node in costs:  
 cost = costs[node]  
 # processed에 존재하지 않는 노드 이면서 경로가 작을때  
 # lowest_cost에 비용(간선)을 담고 lowest_cost_node에 노드(정점)을 저장합니다.  
 # 해당 노드로 가는 최소비용의 노드를 반환합니다.  
 if cost < lowest_cost and node not in processed:  
 lowest_cost = cost  
 lowest_cost_node = node  
 return lowest_cost_node  

node = find_lowest_cost_node(costs)  
while node is not None:  
 cost = costs[node]  
 neighbors = graph[node]  
 for n in neighbors.keys():  
 # 새롭게 설정한 경로의 비용이 기존의 비용보다 작다면  
 # 기존의 비용을 새로운 경로의 비용(간선)으로 교체합니다.  
 # 그리고 이미 쓰여진 경로의 노드는 processed에 저장합니다.  
 new_cost = cost + neighbors[n]  
 if costs[n] > new_cost:  
 costs[n] = new_cost  
 parents[n] = node  
 processed.append(node)  
 #위와 같은 작업을 반복합니다.  
 node = find_lowest_cost_node(costs)  

print("Cost from the start to each node:")  
print(costs)  
```

##### [](#Result "Result")Result

```
Cost from the start to each node:  
{'a': 5, 'b': 2, 'fin': 6}  
```


##### [](#마치며… "마치며…")마치며…

예제 소스를 그대로 가지고와 주석만 다는 건데도 완벽하게 이해하는게 쉽지가 않습니다.  
여기서도 함수는 재귀형태를 띠고 있습니다. 원하는 결과가 나올때까지 반복 수행하고 있네요.  
어렵기도 하지만 재미있기도 하네요 역시.

다음시간에는… 탐욕 알고리즘이군요. 뭐지 이건?!

> Hello Coding 알고리즘, 아디트야 바르가바  
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.

