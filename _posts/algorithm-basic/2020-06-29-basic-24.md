---
title: "[알고리즘-기초2]4.자료 구조(1)"
date: 2019-04-18 14:30:18
categories:
- Algorithm
- 기초
---

#### [](#자료구조란 "자료구조란?")자료구조란?

앞서 데이터가 어떤 것인지, 어떤 구조를 가지고 있는지 알아보았다.  
그럼 이러한 데이터의 정보가 대량으로 발생했을때 어떻게 효율적으로 관리할 것인지에  
대한 방법이 필요하다. 이것이 바로 `자료구조`이다.

데이터를 어떤식으로 저장하며, 어떤식으로 꺼내서 쓸 것인지, 그리고 데이터간의  
어떤 관계를 설정할 것인지에 따라 ‘자료구조’가 결정된다고 할 수 있다.

예를들어 어떤 학교에서 이름 하나만 가지고 학생을 찾는다고 생각해보자.  
이름은 ‘김준현’이다. 전교생을 다 뒤져야 찾을 수 있을 것이다.  
하지만 김준현이라는 학생의 학년/반/번호를 알고 있다면 아주 쉽게 찾을 수 있다.

이것이 자료구조의 존재 이유라고 할 수 있다.

#### [](#자료구조의-종류 "자료구조의 종류")자료구조의 종류

1.  배열 - 데이터가 순차적으로 빈틈 없이 나열된 구조
2.  리스트 - 데이터가 순서대로 존재하지만 위치는 제각각이어서 앞선 데이터가 다음 데이터의 위치를 알려주는 구조
3.  스택 - 데이터가 순차적으로 쌓였다가 나올때는 나중에 쌓인 데이터부터 꺼내오는 구조
4.  큐(대기 행렬)- 먼저 들어온 데이터가 먼저 나가는 구조
5.  트리(나무 구조) - 노드라는 것을 통해 연결된 데이터들이 나눠져 잇는 구조

#### [](#스택 "스택")스택

스택은 ‘쌓다’라는 단어 뜻을 가지고 있다.  
책을 책상 옆에 쌓아둔다고 생각해보자. 우리는 가장 밑에 깔려있는 책을 읽기 위해서는  
위에있는 책들을 하나씩 옮겨야한다.(물론 한꺼번에 옮길 수도 있겠지만)  
월드콘 아이스크림을 먹을때 우리는 가장 아래 깔린 초콜렛을 먹기위해 위에서부터  
맛을 음미해가면 거의 다 먹었을때 비로소 콘의 끝부분에 붙은 초콜렛을 먹을 수 있다.  
(밑에부터 먹는 인싸는 없으시겠지?)

이것이 바로 스택이다.  
스택에 데이터를 넣는 작업을 PUSH, 데이터를 꺼내는 작업을 POP 이라고 한다.  
나중에 들어온 데이터가 먼저 나가기 때문에 `후입선출 - LIFO(Last In, First Out)`이라는 표현을 쓰기도 한다.

#### [](#큐 "큐")큐

큐는 스택과 반대로 먼저들어온 데이터가 먼저 출력된다.  
버스 기다릴때 먼저와서 기다린 사람이 버스를 타고  
마트 계산대에 먼저 온 사람이 계산을 하는 것이라고 보면 된다.

큐에 데이터를 넣는 것을 PUT, 데이터를 꺼내는 것을 GET이라고 한다.  
먼저 들어온 데이터가 먼저 나가기 떄문에 `선입선출 - FIFO(First In, First Out)`이라고 표현한다.

#### [](#리스트 "리스트")리스트

배열과 리스트는 연속된 데이터를 관리한다는 점에서 비슷한 구조를 가지고 있다.  
하지만 배열이 일렬로 데이터를 저장한다면 리스트는 데이터의 위치가 제각각이다.  
다만 리스트의 각 요소들은 다음 요소가 어디에 있는지 위치 정보를 가지고 있다.  
서로가 끈으로 연결되어있다고 생각하면 된다.

배열로도 충분할 것 같은 이런 자료구조에서 리스트가 왜 나오게 됐는지는  
잠시 후에 알아보자.

*   단한뱡 리스트  
    앞의 요소가 뒤에 요소를 알려주는, 즉 한쪽방향으로만 연결된 리스트를 말한다.  
    마지막에 있는 요소를 찾기위해서는 첫번쨰 요소부터 차례대로 접근해야한다.  
    방탈출 카페에서 마지막 열쇠를 찾기위해 첫문제부터 풀어야하는 것처럼 말이다.

*   양방향 리스트  
    요소들이 서로의 위치 정보를 가지고 있다.  
    다음 요소의 정보를 가지고 있는 것을 ‘Next 포인터’  
    이전 요소의 정보를 가지고 있는 것을 ‘Prev 포인터’  
    요소의 첫번째 위치정보를 가지고 있는 것을 ‘HEAD 포인터’  
    요소의 마지막 위치정보를 가지고 있는 것을 ‘TAIL 포인터’ 라고한다.


#### [](#배열과-리스트의-비교 "배열과 리스트의 비교")배열과 리스트의 비교

배열은 특정 요소에 있는 값을 찾아낼 때 매우 빠르다.  
그 배열의 인덱스만 불러오면 되기 때문이다.  
반면에 리스트는 특정 요소에 있는 값을 찾기 위해서는  
첫번째 요소부터 차례로 읽어와서 찾아야한다.  
찾고자 하는 위치 정보를 앞의 요소가 가지고 있기 때문이다.

하지만 데이터를 삽입/삭제할 때는 이야기가 다르다.  
배열의 중간에 데이터를 삽입하기 위해서는 사이의 공간을 확보하여 데이터를 넣고  
그 이후에 배치된 데이터들의 인덱스는 순차적으로 1씩 증가시켜야한다.  
101호 부터 110호까지 방이 차있는 호텔에서  
105호 객실에 사람 하나만 들어가면 원래 105호 있던 사람부터 106호, 107호 이런식으로  
밀리는 구조다. 굉장히 비효율적이고 느릴 수 밖에 없다.  
반면에 리스트는 중간에 데이터를 삽입할때 앞의 요소의 연결고리를 끊고  
그 요소에 넣고자하는 데이터의 주소를 명시하면 된다.  
삽입/삭제의 속도는 리스트가 훨씬 빠르다는 것을 알 수 있다.

장단점이 명확하기에 우리는 배열과 리스트 모두 필요해따라  
적절히 선택하여 사용하면 된다.

{% blockquote 그림으로 배우는 알고리즘, 스기우라 켄 %}
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.
{% endblockquote %}
