---
layout: post
title: "[알고리즘-기초2]6.글로만 구현하는 알고리즘 - 배열편"
date:   2020-06-29 13:50:36
categories: algorithm
---

#### [](#1부터-N까지의-합-구하기 "1부터 N까지의 합 구하기")1부터 N까지의 합 구하기

Step 1. 합계를 저장할 변수 SUM=0 으로 초기화 한다.  
Step 2. VALUE = 1을 넣고 VALUE 값을 1씩 증가시키며 N이 될때까지 반복한다.  
Step 3. SUM = SUM + VALUE를 반복문장 안에서 계속 실행한다.  
Step 4. 반복문이 종료되면 SUM을 반환한다.

#### [](#피보나치-수열-구하기 "피보나치 수열 구하기")피보나치 수열 구하기

Step 1. 피보나치 수열 K개를 저장할 배열 N[K]을 선언한다.  
Step 2. N[0] = 0, N[1] = 1을 저장한다.  
Step 3. VALUE = 2를 넣고 VALUE 값을 1씩 증가시키며 K 미만이 될때까지 반복한다.  
Step 4. N[VALUE] = N[VALUE-2] + N[VALUE-1]을 반복문장 안에서 계속 실행한다.  
Step 5. 반복문이 종료되면 N[]을 반환한다.

#### [](#배열의-합-구하기 "배열의 합 구하기")배열의 합 구하기

Step 1. 배열의 합을 담을 SUM=0 으로 초기화한다.  
Step 2. 배열 A[K]의 VALUE=0부터 VALUE=K-1까지 반복할 반목문장을 만든다.  
Step 3. SUM = SUM + A[VALUE] 반복 문장안에서 실행한다.  
Step 4. VALUE 값을 1증가 시킨다.  
Step 5. 반복문이 종료되면 SUM을 반환한다.

#### [](#배열-요소의-갯수-구하기 "배열 요소의 갯수 구하기")배열 요소의 갯수 구하기

Step 1. 배열 요소의 갯수를 담을 COUNT=0으로 초기화한다.  
Step 2. 배열 A[K]의 VALUE=0부터 VALUE를 1씩 증가하며 반복한다.  
Step 4. 보초값(-1 또는 NULL)이 나오면 반복문을 종료한다.  
Step 3. 반복문장 안에서 COUNT를 1씩 증가시킨다.  
Step 5. 반복문이 종료되면 COUNT를 반환한다.

*   많은 프로그래밍 언어들은 배열 요소의 갯수를 구할 수 있는 내장함수를 기본적으로 제공한다.

#### [](#배열-값의-합계-평균-구하기 "배열 값의 합계/평균 구하기")배열 값의 합계/평균 구하기

Step 1. 합계를 담을 SUM=0 요소의 갯수를 담을 COUNT=0으로 초기화한다.  
Step 2. 배열 A[K]의 VALUE=0부터 VALUE=K-1까지 반복할 반목문장을 만든다.  
Step 3. SUM = SUM + A[VALUE], COUNT = COUNT + 1 반복 문장안에서 실행한다.  
Step 4. 반복문이 종료되면 합계는 SUM으로 평균은 SUM/COUNT로 반환한다.

#### [](#배열의-최대값-구하기 "배열의 최대값 구하기")배열의 최대값 구하기

Step 1. 최대값을 저장할 변수 MAX=0으로 초기화한다.  
(만약 음수를 포함할 경우 배열 A[0]을 기준값으로 정한다.)  
Step 2. 배열 A[K]의 VALUE=0부터 VALUE=K-1까지 반복할 반목문장을 만든다.  
Step 3. MAX값과 A[VALUE]값을 비교하여 A[VALUE]가 크다면 MAX = A[VALUE]를 저장한다.  
Step 4. 반복문이 종료되면 MAX를 반환한다.

#### [](#배열의-RANK-구하기 "배열의 RANK 구하기")배열의 RANK 구하기

Step 1. 점수가 저장된 배열이 S[]라면 요소의 갯수가 동일한 RANK[] 배열을 선언한다.  
Step 2. RANK 배열의 값은 모두 1로 초기화 시킨다.  
Step 3. S[K] 배열의 인덱스 I를 0부터 K-1까지 반복할 반복문장을 만든다.  
Step 4. 반복문 안에 S[K] 배열의 인덱스 J를 0부터 K-1까지 반복할 반복문장을 만든다.  
Step 5. S[I]와 S[J]를 비교한다. S[I] < S[J]일 경우 RANK[I]의 값을 1증가시킨다.  
Step 6. 이중으로된 반복문이 종료되면 RANK를 반환한다.

#### [](#시간-시분초-비교하기 "시간(시분초) 비교하기")시간(시분초) 비교하기

Step 1. 시분초로 표기된 2개의 변수 T1,T2를 준비한다.  
Step 2. 각 변수를 초로만 표기되도록 한다.  
Step 3. T1의 시 _3600 + T1의 분_ 60 + T1의 초  
Step 4. T2의 시 _3600 + T2의 분_ 60 + T2의 초  
Step 5. Step 3과 Step 4의 뺄셈을 통해 크기 차이를 비교한다.  
Step 6-1. 정확한 차이를 구하고 싶다면 큰 수에서 작은 수를 빼서 DIFF 변수에 넣는다.  
Step 6-2. DIFF를 3600으로 나눈 몫을 H변수에 넣는다.  
Step 6-3. DIFF를 3600으로 나눈 나머지를 60으로 나누어 M변수에 넣는다.  
Step 6-4. DIFF를 3600으로 나눈 나머지를 60으로 나눈 나머지를 S변수에 넣는다.  
Step 6-5. 결과를 H시:M분:S초로 표현한다.

#### [](#변수-값-교환하기 "변수 값 교환하기")변수 값 교환하기

Step 1. V1, V2의 값을 지정한다.  
Step 2. 교환 역할을 할 C 변수를 초기화한다.  
Step 3. C에 V1 값을 넣는다.  
Step 4. V1에 V2 값을 넣는다.  
Step 5. V2에 C의 값을 넣는다.

#### [](#두-수의-최대-공약수-구하기 "두 수의 최대 공약수 구하기")두 수의 최대 공약수 구하기

Step 1. 최대 공약수를 구하려는 V1, V2 값을 지정한다.  
Step 2. 큰 수에서 작은 수를 나누어 나머지를 X 값에 넣는다.  
Step 3. V1,V2 중 작은 수를 X로 나눈 나머지를 Y에 넣는다.  
Step 4. X를 Y로 나누어 X값에 Y를 넣고 나머지는 Y에 넣는다.  
Step 5. 나머지가 0이 될때까지 위의 작업을 반복한다.  
Step 6. 0이 되면 Y를 반환한다.

> 그림으로 배우는 알고리즘, 스기우라 켄  
해당 포스팅은 다음의 도서을 참고하여 작성되었습니다.

